# AsioTcpClient 项目技术讲解

## 一、项目概述

AsioTcpClient 是一个基于 **Boost.Asio** 库实现的高性能 TCP 客户端，具备自动重连功能。项目采用现代 C++17 标准开发，支持跨平台运行（Windows/Linux/macOS）。

### 核心特性
- **异步非阻塞 IO** - 基于 Reactor 模式
- **自动重连机制** - 指数退避策略
- **自定义协议支持** - 长度前缀分帧
- **线程安全** - 支持多线程环境
- **事件驱动** - 回调式 API 设计

---

## 二、技术架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      应用层 (Application)                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │   setOnConnected() / setOnMessage() / send()        │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                      客户端层 (TcpClient)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  连接管理     │  │  消息收发     │  │  重连机制     │      │
│  │  doConnect() │  │  doRead()    │  │  doReconnect()│      │
│  │  handleConn()│  │  doWrite()   │  │  backoff计算  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
├─────────────────────────────────────────────────────────────┤
│                      协议层 (Message)                        │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  +------------+----------------------------------+  │   │
│  │  | 4字节长度头 |          消息体 (变长)            |  │   │
│  │  | (网络字节序)|                                  |  │   │
│  │  +------------+----------------------------------+  │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                      网络层 (Asio)                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  io_context  │  │  tcp::socket │  │ steady_timer │      │
│  │  事件循环     │  │  套接字操作   │  │  定时器       │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心组件说明

| 组件 | 文件 | 职责 |
|------|------|------|
| TcpClient | TcpClient.h/cpp | 客户端主类，管理连接生命周期 |
| Message | Message.h | 消息协议编解码 |
| ReconnectConfig | TcpClient.h | 重连策略配置 |

---

## 三、核心技术点详解

### 3.1 异步 IO 模型

采用 Asio 的 **Proactor 模式**，所有 IO 操作都是异步非阻塞的：

```cpp
// 异步连接
asio::async_connect(socket_, endpoints,
    [this, self](const std::error_code& ec, const auto&) {
        handleConnect(ec);  // 连接完成后回调
    }
);

// 异步读取
asio::async_read(socket_, asio::buffer(headerBuffer_),
    [this, self](const std::error_code& ec, std::size_t) {
        // 读取完成后处理
    }
);
```

**优势**：
- 单线程可处理大量并发连接
- 不阻塞调用线程
- CPU 利用率高

### 3.2 消息分帧协议

采用 **长度前缀协议**（Length-Prefixed Protocol）：

```
报文格式:
+------------------+--------------------+
|    Length (4B)   |    Body (变长)      |
|   网络字节序      |                    |
+------------------+--------------------+
```

**编码过程**：
```cpp
std::vector<char> Message::encode() const {
    std::vector<char> result(HEADER_SIZE + body_.size());

    // 1. 写入长度头（网络字节序）
    uint32_t len = htonl(static_cast<uint32_t>(body_.size()));
    std::memcpy(result.data(), &len, HEADER_SIZE);

    // 2. 写入消息体
    std::memcpy(result.data() + HEADER_SIZE, body_.data(), body_.size());

    return result;
}
```

**解码过程**：
```cpp
// 1. 先读取 4 字节头
doReadHeader() → async_read(headerBuffer_)

// 2. 解析长度
uint32_t bodyLen = ntohl(*(uint32_t*)headerBuffer_.data());

// 3. 根据长度读取消息体
doReadBody(bodyLen) → async_read(bodyBuffer_)
```

### 3.3 自动重连机制

采用 **指数退避算法**（Exponential Backoff）：

```
重连间隔 = min(初始间隔 × 2^重试次数, 最大间隔)

实际序列: 1s → 2s → 4s → 8s → 16s → 30s → 30s → ...
```

**实现代码**：
```cpp
std::chrono::milliseconds TcpClient::calculateReconnectDelay() {
    if (reconnectAttempts_ == 0) {
        return reconnectConfig_.initialDelay;  // 1秒
    }

    // 指数退避
    double multiplier = std::pow(backoffMultiplier, reconnectAttempts_);
    auto delay = initialDelay * multiplier;

    // 限制最大延迟
    return std::min(delay, maxDelay);  // 最大30秒
}
```

**状态转换图**：
```
                    connect()
    [Disconnected] ─────────→ [Connecting]
          ↑                        │
          │                        ↓ 成功
          │                   [Connected]
          │                        │
          │ 用户主动断开            │ 连接断开
          │                        ↓
          └──────────────── [Reconnecting]
                                   │
                                   └→ 定时器触发 → [Connecting]
```

### 3.4 线程安全设计

**写队列保护**：
```cpp
void TcpClient::send(const Message& message) {
    auto encoded = message.encode();

    // 投递到 IO 线程执行
    asio::post(ioContext_, [this, data = std::move(encoded)]() mutable {
        bool writeInProgress;
        {
            std::lock_guard<std::mutex> lock(writeMutex_);  // 加锁
            writeInProgress = !writeQueue_.empty();
            writeQueue_.push(std::move(data));
        }

        if (!writeInProgress && isConnected()) {
            doWrite();
        }
    });
}
```

**设计原则**：
- 所有 IO 操作在 `io_context` 线程执行
- 跨线程调用通过 `asio::post()` 投递
- 共享数据使用 `mutex` 保护

### 3.5 生命周期管理

使用 `std::enable_shared_from_this` 确保异步回调中对象有效：

```cpp
class TcpClient : public std::enable_shared_from_this<TcpClient> {
    void doConnect() {
        auto self = shared_from_this();  // 延长生命周期

        asio::async_connect(socket_, endpoints,
            [this, self](const std::error_code& ec, ...) {
                // self 保证 this 在回调时有效
                handleConnect(ec);
            }
        );
    }
};
```

---

## 四、项目结构

```
AsioTcpClient/
├── CMakeLists.txt          # CMake 构建配置
├── include/
│   ├── Message.h           # 消息协议 (97行)
│   └── TcpClient.h         # 客户端接口 (133行)
├── src/
│   └── TcpClient.cpp       # 客户端实现 (280行)
└── examples/
    └── main.cpp            # 使用示例 (140行)
```

**代码统计**：约 650 行 C++ 代码

---

## 五、使用方式

### 5.1 基本用法

```cpp
#include "TcpClient.h"
using namespace asioclient;

int main() {
    asio::io_context ioContext;
    auto client = createClient(ioContext);

    // 设置回调
    client->setOnConnected([]() {
        std::cout << "Connected!" << std::endl;
    });

    client->setOnMessage([](const Message& msg) {
        std::cout << "Received: " << msg.bodyAsString() << std::endl;
    });

    // 连接服务器
    client->connect("127.0.0.1", 8888);

    // 发送消息
    client->send("Hello, Server!");

    // 运行事件循环
    ioContext.run();
}
```

### 5.2 配置重连策略

```cpp
ReconnectConfig config;
config.enabled = true;
config.initialDelay = std::chrono::milliseconds(1000);  // 1秒
config.maxDelay = std::chrono::milliseconds(30000);     // 30秒
config.backoffMultiplier = 2.0;
config.maxRetries = 10;  // 最多重试10次，-1为无限

client->setReconnectConfig(config);
```

---

## 六、技术选型理由

| 技术 | 选择 | 理由 |
|------|------|------|
| 网络库 | Boost.Asio | 成熟稳定、跨平台、功能完善、Boost 生态系统支持 |
| C++ 标准 | C++17 | std::any、结构化绑定等特性 |
| 协议格式 | 长度前缀 | 简单可靠、边界清晰 |
| 重连策略 | 指数退避 | 避免服务器过载、网络友好 |

---

## 七、扩展方向

1. **SSL/TLS 支持** - 集成 boost::asio::ssl
2. **连接池** - 管理多个连接
3. **心跳机制** - 检测连接存活
4. **压缩传输** - 集成 zlib
5. **协议扩展** - 支持 Protobuf/JSON
